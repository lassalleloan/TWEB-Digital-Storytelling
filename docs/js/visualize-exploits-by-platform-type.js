/**
 * Generate a treemap chart to show number of exploits by platfrom and type with D3.js
 * author: Loan Lassalle
 */
function treeMap() {
  const d3v3 = d3;

  console.log('Treemap chart generation with D3.js : Exploits by platform and type');

  const svgExploitsByPlatformType = d3v3.select('#exploits-by-platform-type');

  // Set the dimensions and margins of the graph and zoom's zone
  const margin = {
    top: 45, right: 10, bottom: 80, left: 20,
  };
  const width = +svgExploitsByPlatformType.attr('width') - margin.left - margin.right;
  const height = +svgExploitsByPlatformType.attr('height') - margin.top - margin.bottom;

  // Set scales
  const x = d3v3.scale.linear()
    .range([0, width]);
  const y = d3v3.scale.linear()
    .range([0, height]);

  // Set color
  const color = d3v3.scale.category20c();

  let node;

  const treemap = d3v3.layout.treemap()
    .round(false)
    .size([width, height])
    .sticky(true)
    .value(d => d.size);

  const svg = svgExploitsByPlatformType.append('svg:g')
    .attr('transform', 'translate(.5,.5)');

  // Get the data
  d3v3.csv('dataset/files.csv', (error, dataCsv) => {
    if (error) throw error;

    // Format the data
    const data = {
      name: 'files',
      children: d3v3.nest()
        .key(d => d.type)
        .key(d => d.platform)
        .rollup(d => d.length)
        .sortKeys(d3v3.ascending)
        .sortValues((a, b) => a.val - b.val)
        .entries(dataCsv)
        .map(d => ({
          name: d.key,
          children: d.values.map(value => ({
            name: value.key,
            size: value.values,
          })),
        })),
    };

    const root = data;
    node = data;

    const nodes = treemap.nodes(root)
      .filter(d => !d.children);

    const cell = svg.selectAll('g')
      .data(nodes)
      .enter().append('svg:g')
      .attr('class', 'cell')
      .attr('transform', d => `translate(${d.x},${d.y})`)
      .on('click', d => zoom(node === d.parent ? root : d.parent));

    cell.append('svg:rect')
      .attr('width', (d) => { const t = d.dx - 1; return t < 0 ? 0 : t; })
      .attr('height', (d) => { const t = d.dy - 1; return t < 0 ? 0 : t; })
      .style('fill', d => color(d.parent.name));

    cell.append('svg:text')
      .attr('x', d => d.dx / 2)
      .attr('y', d => d.dy / 2)
      .attr('dy', '.35em')
      .attr('text-anchor', 'middle')
      .text(d => d.name)
      .style('opacity', opacity);

    const legendHolder = svg.append('g')
      .attr('transform', `translate(0,${height + 20})`);

    const legend = legendHolder.selectAll('g')
      .data(color.domain())
      .enter()
      .append('g')
      .attr('class', 'legend')
      .attr('transform', (d, i) => {
        const height2 = 20;
        const x2 = 0;
        const y2 = i * height2;
        return `translate(${x2},${y2})`;
      });

    legend.append('rect')
      .attr('width', 20)
      .attr('height', 20)
      .style('fill', color)
      .style('stroke', color);

    legend.append('text')
      .attr('x', 20 + 5)
      .attr('y', 20 - 5)
      .text(d => d);

    d3v3.select(window).on('click', () => {
      zoom(root);
    });

    d3v3.select('select').on('change', () => {
      treemap.value(this.value === 'size' ? this.value.size : 1).nodes(root);
      zoom(node);
    });
  });

  function opacity(d) {
    d.w = this.getComputedTextLength();
    return d.dx > d.w ? 1 : 0;
  }

  function zoom(d) {
    const kx = width / d.dx;
    const ky = height / d.dy;
    x.domain([d.x, d.x + d.dx]);
    y.domain([d.y, d.y + d.dy]);

    const t = svg.selectAll('g.cell')
      .transition()
      .duration(d3v3.event.altKey ? 7500 : 750)
      .attr('transform', e => `translate(${x(e.x)},${y(e.y)})`);

    t.select('rect')
      .attr('width', (e) => { const f = (kx * e.dx) - 1; return f < 0 ? 0 : f; })
      .attr('height', (e) => { const f = (ky * e.dy) - 1; return f < 0 ? 0 : f; });

    t.select('text')
      .attr('x', e => (kx * e.dx) / 2)
      .attr('y', e => (ky * e.dy) / 2)
      .style('opacity', e => (kx * e.dx > e.w ? 1 : 0));

    node = d;
    d3v3.event.stopPropagation();
  }
}

treeMap();
