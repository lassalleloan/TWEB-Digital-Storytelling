/**
 * author: Loan Lassalle
 */

function treeMap() {
  const d3v4 = d3;

  console.log('Treemap chart generation with D3.js : Exploits by platform and type');

  const w = 1104 - 80;
  const h = 713 - 180;
  const x = d3v4.scale.linear().range([0, w]);
  const y = d3v4.scale.linear().range([0, h]);
  const color = d3v4.scale.category20c();
  let root;
  let node;

  const treemap = d3v4.layout.treemap()
    .round(false)
    .size([w, h])
    .sticky(true)
    .value(d => d.size);

  const svg = d3v4.select('#exploits-by-platform-type')
    .append('svg:svg')
    .attr('width', w)
    .attr('height', h)
    .append('svg:g')
    .attr('transform', 'translate(.5,.5)');

  // Get the data
  d3v4.csv('dataset/files.csv', (error, dataCsv) => {
    if (error) throw error;

    // Format the data
    const data = {
      name: 'files',
      children: d3v4.nest()
        .key(d => d.type)
        .key(d => d.platform)
        .rollup(d => d.length)
        .sortKeys(d3v4.ascending)
        .sortValues((a, b) => a.val - b.val)
        .entries(dataCsv)
        .map(d => ({
          name: d.key,
          children: d.values.map(value => ({
            name: value.key,
            size: value.values,
          })),
        })),
    };

    node = root = data;

    const nodes = treemap.nodes(root)
      .filter(d => !d.children);

    const cell = svg.selectAll('g')
      .data(nodes)
      .enter().append('svg:g')
      .attr('class', 'cell')
      .attr('transform', d => `translate(${d.x},${d.y})`)
      .on('click', d => zoom(node == d.parent ? root : d.parent));

    cell.append('svg:rect')
      .attr('width', (d) => { const t = d.dx - 1; return t < 0 ? 0 : t; })
      .attr('height', (d) => { const t = d.dy - 1; return t < 0 ? 0 : t; })
      .style('fill', d => color(d.parent.name));

    cell.append('svg:text')
      .attr('x', d => d.dx / 2)
      .attr('y', d => d.dy / 2)
      .attr('dy', '.35em')
      .attr('text-anchor', 'middle')
      .text(d => d.name)
      .style('opacity', function (d) { d.w = this.getComputedTextLength(); return d.dx > d.w ? 1 : 0; });

    d3v4.select(window).on('click', () => {
      zoom(root);
    });

    d3v4.select('select').on('change', function () {
      treemap.value(this.value == 'size' ? size : count).nodes(root);
      zoom(node);
    });
  });

  function size(d) {
    return d.size;
  }

  function count(d) {
    return 1;
  }

  function zoom(d) {
    const kx = w / d.dx;
    const ky = h / d.dy;
    x.domain([d.x, d.x + d.dx]);
    y.domain([d.y, d.y + d.dy]);

    const t = svg.selectAll('g.cell').transition()
      .duration(d3v4.event.altKey ? 7500 : 750)
      .attr('transform', d => `translate(${x(d.x)},${y(d.y)})`);

    t.select('rect')
      .attr('width', (d) => { const t = kx * d.dx - 1; return t < 0 ? 0 : t; })
      .attr('height', (d) => { const t = ky * d.dy - 1; return t < 0 ? 0 : t; });

    t.select('text')
      .attr('x', d => kx * d.dx / 2)
      .attr('y', d => ky * d.dy / 2)
      .style('opacity', d => (kx * d.dx > d.w ? 1 : 0));

    node = d;
    d3v4.event.stopPropagation();
  }
}

treeMap();
