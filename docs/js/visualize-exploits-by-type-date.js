/**
 * Generate mutiple charts to show number of exploits by type and date and type with D3.js
 * author: Loan Lassalle
 */

function addYears(date, years) {
  const d = new Date(date);
  d.setFullYear(d.getFullYear() + years);

  return d;
}

function addMonths(date, months) {
  const d = new Date(date);
  d.setMonth(d.getMonth() + months);

  return d;
}

function allDates(startDate, endDate, addFn, interval) {
  const dates = [];
  let currentDate = startDate;

  const fn = addFn || addMonths;

  while (currentDate <= endDate) {
    const d = new Date(currentDate);
    d.setHours(0, 0, 0, 0, 0);
    dates.push(d);
    currentDate = fn(currentDate, interval || 1);
  }

  return dates;
}

function addOptions() {
  const d3v3 = d3;
  const idStartYear = d3v3.select('#startYear');
  const idEndYear = d3v3.select('#endYear');

  const yearsRef = allDates(new Date('1987'), new Date(new Date().getFullYear().toString()), addYears)
    .map(d => d.getFullYear());

  idStartYear.selectAll('option')
    .data(yearsRef)
    .enter()
    .append('option')
    .attr('value', d => d)
    .text(d => d);

  idEndYear.selectAll('option')
    .data(yearsRef)
    .enter()
    .append('option')
    .attr('value', d => d)
    .text(d => d);

  d3v3.select('#startYear').property('value', '2010');
  d3v3.select('#endYear').property('value', '2017');
}

function showReel() {
  const d3v3 = d3;

  console.log('Multiple charts generation with D3.js : Exploits by type and date');

  const svgExploitsByTypeDate = d3v3.select('#exploits-by-type-date');

  // Remove all children
  svgExploitsByTypeDate.selectAll('*').remove();

  // Set the dimensions and margins of the graph
  const margin = {
    top: 20, right: 20, bottom: 30, left: 20,
  };
  const width = +svgExploitsByTypeDate.attr('width') - margin.left - margin.right;
  const height = +svgExploitsByTypeDate.attr('height') - margin.top - margin.bottom;

  let x;
  let y;
  const duration = 2000;
  const delay = 500;

  // Set color
  const color = d3v3.scale.category10();

  const exploitsByTypeDate = svgExploitsByTypeDate.append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);

  let symbols;

  // A line generator, for the dark stroke
  const line = d3v3.svg.line()
    .interpolate('basis')
    .x(d => x(d.date))
    .y(d => y(d.price));

  // A line generator, for the dark stroke
  const axis = d3v3.svg.line()
    .interpolate('basis')
    .x(d => x(d.date))
    .y(height);

  // An area generator, for the dark stroke
  const area = d3v3.svg.area()
    .interpolate('basis')
    .x(d => x(d.date))
    .y1(d => y(d.price));

  d3v3.csv('dataset/files.csv', (error, dataCsv) => {
    if (error) throw error;

    const parse = d3v3.time.format('%Y-%m').parse;

    // Format the data
    symbols = d3v3.nest()
      .key(d => d.type)
      .key(d => d.date)
      .rollup(d => d.length)
      .sortKeys(d3v3.ascending)
      .sortValues((a, b) => a.val - b.val)
      .entries(dataCsv)
      .map(d => ({
        key: d.key,
        values: d.values.map(value => ({
          symbol: d.key,
          date: parse(value.key.substr(0, value.key.lastIndexOf('-'))),
          price: value.values,
        })),
        maxPrice: d3v3.max(d.values, e => e.values),
        sumPrice: d3v3.sum(d.values, e => e.values),
      }));

    const datesRef = allDates(new Date(d3v3.select('#startYear').node().value), new Date(d3v3.select('#endYear').node().value));

    symbols = symbols.map(d => ({
      key: d.key,
      values: datesRef.map((k) => {
        value = d.values.filter(v => v.date.getFullYear() === k.getFullYear() && v.date.getMonth() === k.getMonth())[0];
        return value || ({ symbol: d.key, date: k, price: 0 });
      }),
      maxPrice: d3v3.max(d.values, e => e.price),
      sumPrice: d3v3.sum(d.values, e => e.price),
    }));

    // Sort by maximum price, descending
    symbols.sort((a, b) => b.maxPrice - a.maxPrice);

    exploitsByTypeDate.selectAll('g')
      .data(symbols)
      .enter()
      .append('g')
      .attr('class', 'symbol');

    setTimeout(lines, duration);
  });

  function lines() {
    x = d3v3.time.scale()
      .range([0, width - 60]);
    y = d3v3.scale.linear()
      .range([(height / 4) - 20, 0]);

    // Compute the minimum and maximum date across symbols.
    x.domain([
      d3v3.min(symbols, d => d.values[0].date),
      d3v3.max(symbols, d => d.values[d.values.length - 1].date),
    ]);

    const g = exploitsByTypeDate.selectAll('.symbol')
      .attr('transform', (d, i) => `translate(0,${((i * height) / 5) + 10})`);

    g.each(function (d) {
      const e = d3v3.select(this);

      e.append('path')
        .attr('class', 'line');

      e.append('circle')
        .attr('r', 5)
        .style('fill', d => color(d.key))
        .style('stroke', '#000')
        .style('stroke-width', '2px');

      e.append('text')
        .attr('x', 12)
        .attr('dy', '.31em')
        .text(d.key);
    });

    function draw(k) {
      g.each(function (d) {
        const e = d3v3.select(this);
        y.domain([0, d.maxPrice]);

        e.select('path')
          .attr('d', d => line(d.values.slice(0, k + 1)));

        e.selectAll('circle, text')
          .data(d => [d.values[k], d.values[k]])
          .attr('transform', d => `translate(${x(d.date)},${y(d.price)})`);
      });
    }

    let k = 1;
    const n = symbols[0].values.length;

    d3v3.timer(() => {
      draw(k);
      if ((k += 2) >= n - 1) {
        draw(n - 1);
        setTimeout(horizons, 500);
        return true;
      }
    });
  }

  function horizons() {
    exploitsByTypeDate.insert('defs', '.symbol')
      .append('clipPath')
      .attr('id', 'clip')
      .append('rect')
      .attr('width', width + 60)
      .attr('height', (height / 4) + 20);

    const color2 = d3v3.scale.ordinal()
      .range(['#c6dbef', '#9ecae1', '#6baed6']);

    const g = exploitsByTypeDate.selectAll('.symbol')
      .attr('clip-path', 'url(#clip)');

    area.y0((height / 4) - 20);

    g.select('circle').transition()
      .duration(duration)
      .attr('transform', () => `translate(${width - 60},${-height / 4})`)
      .remove();

    g.select('text').transition()
      .duration(duration)
      .attr('transform', () => `translate(${width - 60},${(height / 4) - 20})`)
      .attr('dy', '0em');

    g.each(function (d) {
      y.domain([0, d.maxPrice]);

      d3v3.select(this).selectAll('.area')
        .data(d3v3.range(3))
        .enter()
        .insert('path', '.line')
        .attr('class', 'area')
        .attr('transform', d => `translate(0,${d * ((height / 4) - 20)})`)
        .attr('d', area(d.values))
        .style('fill', (d, i) => color2(i))
        .style('fill-opacity', 1e-6);

      y.domain([0, d.maxPrice / 3]);

      d3v3.select(this).selectAll('.line').transition()
        .duration(duration)
        .attr('d', line(d.values))
        .style('stroke-opacity', 1e-6);

      d3v3.select(this).selectAll('.area').transition()
        .duration(duration)
        .style('fill-opacity', 1)
        .attr('d', area(d.values))
        .each('end', function () { d3v3.select(this).style('fill-opacity', null); });
    });

    setTimeout(areas, duration + delay);
  }

  function areas() {
    const g = exploitsByTypeDate.selectAll('.symbol');

    axis.y((height / 4) - 21);

    g.select('.line')
      .attr('d', d => axis(d.values));

    g.each(function (d) {
      y.domain([0, d.maxPrice]);

      d3v3.select(this)
        .select('.line')
        .transition()
        .duration(duration)
        .style('stroke-opacity', 1)
        .each('end', function () { d3v3.select(this).style('stroke-opacity', null); });

      d3v3.select(this)
        .selectAll('.area')
        .filter((d, i) => i)
        .transition()
        .duration(duration)
        .style('fill-opacity', 1e-6)
        .attr('d', area(d.values))
        .remove();

      d3v3.select(this)
        .selectAll('.area')
        .filter((d, i) => !i)
        .transition()
        .duration(duration)
        .style('fill', color(d.key))
        .attr('d', area(d.values));
    });

    exploitsByTypeDate.select('defs')
      .transition()
      .duration(duration)
      .remove();

    g.transition()
      .duration(duration)
      .each('end', function () { d3v3.select(this).attr('clip-path', null); });

    setTimeout(stackedArea, duration + delay);
  }

  function stackedArea() {
    const stack = d3v3.layout.stack()
      .values(d => d.values)
      .x(d => d.date)
      .y(d => d.price)
      .out((d, y0, y) => { d.price0 = y0; })
      .order('reverse');

    stack(symbols);

    y.domain([0, d3v3.max(symbols[0].values.map(d => d.price + d.price0))])
      .range([height, 0]);

    line.y(d => y(d.price0));

    area.y0(d => y(d.price0))
      .y1(d => y(d.price0 + d.price));

    const t = exploitsByTypeDate.selectAll('.symbol').transition()
      .duration(duration)
      .attr('transform', 'translate(0,0)')
      .each('end', function () { d3v3.select(this).attr('transform', null); });

    t.select('path.area')
      .attr('d', d => area(d.values));

    t.select('path.line')
      .style('stroke-opacity', (d, i) => (i < 3 ? 1e-6 : 1))
      .attr('d', d => line(d.values));

    t.select('text')
      .attr('transform', (d) => { d = d.values[d.values.length - 1]; return `translate(${width - 60},${y((d.price / 2) + d.price0)})`; });

    setTimeout(streamgraph, duration + delay);
  }

  function streamgraph() {
    const stack = d3v3.layout.stack()
      .values(d => d.values)
      .x(d => d.date)
      .y(d => d.price)
      .out((d, y0, y) => { d.price0 = y0; })
      .order('reverse')
      .offset('wiggle');

    stack(symbols);

    line.y(d => y(d.price0));

    const t = exploitsByTypeDate.selectAll('.symbol')
      .transition()
      .duration(duration);

    t.select('path.area')
      .attr('d', d => area(d.values));

    t.select('path.line')
      .style('stroke-opacity', 1e-6)
      .attr('d', d => line(d.values));

    t.select('text')
      .attr('transform', (d) => { d = d.values[d.values.length - 1]; return `translate(${width - 60},${y((d.price / 2) + d.price0)})`; });

    setTimeout(overlappingArea, duration + delay);
  }

  function overlappingArea() {
    const g = exploitsByTypeDate.selectAll('.symbol');

    line.y(d => y(d.price0 + d.price));

    g.select('.line')
      .attr('d', d => line(d.values));

    y.domain([0, d3v3.max(symbols.map(d => d.maxPrice))])
      .range([height, 0]);

    area.y0(height)
      .y1(d => y(d.price));

    line.y(d => y(d.price));

    const t = g.transition()
      .duration(duration);

    t.select('.line')
      .style('stroke-opacity', 1)
      .attr('d', d => line(d.values));

    t.select('.area')
      .style('fill-opacity', 0.5)
      .attr('d', d => area(d.values));

    t.select('text')
      .attr('dy', '.31em')
      .attr('transform', (d) => { d = d.values[d.values.length - 1]; return `translate(${width - 60},${y(d.price)})`; });

    exploitsByTypeDate.append('line')
      .attr('class', 'line')
      .attr('x1', 0)
      .attr('x2', width - 60)
      .attr('y1', height)
      .attr('y2', height)
      .style('stroke-opacity', 1e-6)
      .transition()
      .duration(duration)
      .style('stroke-opacity', 1);

    setTimeout(groupedBar, duration + delay);
  }

  function groupedBar() {
    x = d3v3.scale.ordinal()
      .domain(symbols[0].values.map(d => d.date))
      .rangeBands([0, width - 60], 0.1);

    const x1 = d3v3.scale.ordinal()
      .domain(symbols.map(d => d.key))
      .rangeBands([0, x.rangeBand()]);

    const g = exploitsByTypeDate.selectAll('.symbol');

    const t = g.transition()
      .duration(duration);

    t.select('.line')
      .style('stroke-opacity', 1e-6)
      .remove();

    t.select('.area')
      .style('fill-opacity', 1e-6)
      .remove();

    g.each(function (p, j) {
      d3v3.select(this).selectAll('rect')
        .data(d => d.values)
        .enter()
        .append('rect')
        .attr('x', d => x(d.date) + x1(p.key))
        .attr('y', d => y(d.price))
        .attr('width', x1.rangeBand())
        .attr('height', d => height - y(d.price))
        .style('fill', color(p.key))
        .style('fill-opacity', 1e-6)
        .transition()
        .duration(duration)
        .style('fill-opacity', 1);
    });

    setTimeout(stackedBar, duration + delay);
  }

  function stackedBar() {
    x.rangeRoundBands([0, width - 60], 0.1);

    const stack = d3v3.layout.stack()
      .values(d => d.values)
      .x(d => d.date)
      .y(d => d.price)
      .out((d, y0, y) => { d.price0 = y0; })
      .order('reverse');

    const g = exploitsByTypeDate.selectAll('.symbol');

    stack(symbols);

    y.domain([0, d3v3.max(symbols[0].values.map(d => d.price + d.price0))])
      .range([height, 0]);

    const t = g.transition()
      .duration(duration / 2);

    t.select('text')
      .delay(symbols[0].values.length * 10)
      .attr('transform', (d) => { d = d.values[d.values.length - 1]; return `translate(${width - 60},${y((d.price / 2) + d.price0)})`; });

    t.selectAll('rect')
      .delay((d, i) => i * 10)
      .attr('y', d => y(d.price0 + d.price))
      .attr('height', d => height - y(d.price))
      .each('end', function () {
        d3v3.select(this)
          .style('stroke', '#fff')
          .style('stroke-opacity', 1e-6)
          .transition()
          .duration(duration / 2)
          .attr('x', d => x(d.date))
          .attr('width', x.rangeBand())
          .style('stroke-opacity', 1);
      });

    setTimeout(transposeBar, duration + (symbols[0].values.length * 10) + delay);
  }

  function transposeBar() {
    x.domain(symbols.map(d => d.key))
      .rangeRoundBands([0, width], 0.2);

    y.domain([0, d3v3.max(symbols.map(d => d3v3.sum(d.values.map(d => d.price))))]);

    const stack = d3v3.layout.stack()
      .x((d, i) => i)
      .y(d => d.price)
      .out((d, y0, y) => { d.price0 = y0; });

    stack(d3v3.zip.apply(null, symbols.map(d => d.values))); // transpose!

    const g = exploitsByTypeDate.selectAll('.symbol');

    const t = g.transition()
      .duration(duration / 2);

    t.selectAll('rect')
      .delay((d, i) => i * 10)
      .attr('y', d => y(d.price0 + d.price) - 1)
      .attr('height', d => (height - y(d.price)) + 1)
      .attr('x', d => x(d.symbol))
      .attr('width', x.rangeBand())
      .style('stroke-opacity', 1e-6);

    t.select('text')
      .attr('x', 0)
      .attr('transform', d => `translate(${x(d.key) + (x.rangeBand() / 2)},${height})`)
      .attr('dy', '1.31em')
      .each('end', function () { d3v3.select(this).attr('x', null).attr('text-anchor', 'middle'); });

    exploitsByTypeDate.select('line').transition()
      .duration(duration)
      .attr('x2', width);

    setTimeout(donut, (duration / 2) + (symbols[0].values.length * 10) + delay);
  }

  function donut() {
    const g = exploitsByTypeDate.selectAll('.symbol');

    g.selectAll('rect').remove();

    const pie = d3v3.layout.pie()
      .value(d => d.sumPrice);

    const arc = d3v3.svg.arc();

    g.append('path')
      .style('fill', d => color(d.key))
      .data(() => pie(symbols))
      .transition()
      .duration(duration)
      .tween('arc', arcTween);

    g.select('text').transition()
      .duration(duration)
      .attr('dy', '.31em');

    exploitsByTypeDate.select('line').transition()
      .duration(duration)
      .attr('y1', 2 * height)
      .attr('y2', 2 * height)
      .remove();

    function arcTween(d) {
      const path = d3v3.select(this);
      const text = d3v3.select(this.parentNode.appendChild(this.previousSibling));
      const x0 = x(d.data.key);
      const y0 = height - y(d.data.sumPrice);

      return function (t) {
        const r = (height / 2) / Math.min(1, t + 1e-3);
        const a = Math.cos(t * Math.PI / 2);
        const xx = (-r + ((a) * (x0 + x.rangeBand())) + (((1 - a) * (width + height)) / 2));
        const yy = (((a) * height) + (((1 - a) * height) / 2));
        const f = {
          innerRadius: r - (x.rangeBand() / (2 - a)),
          outerRadius: r,
          startAngle: (a * ((Math.PI / 2) - (y0 / r))) + ((1 - a) * d.startAngle),
          endAngle: (a * (Math.PI / 2)) + ((1 - a) * d.endAngle),
        };

        path.attr('transform', `translate(${xx},${yy})`);
        path.attr('d', arc(f));
        text.attr('transform', `translate(${arc.centroid(f)})translate(${xx},${yy})rotate(${(((f.startAngle + f.endAngle) / 2) + (((3 * Math.PI) / 2) * 180)) / Math.PI})`);
      };
    }

    setTimeout(donutExplode, duration + delay);
  }

  function donutExplode() {
    const r0a = (height / 2) - (x.rangeBand() / 2);
    const r1a = height / 2;
    const r0b = (2 * height) - (x.rangeBand() / 2);
    const r1b = 2 * height;
    const arc = d3v3.svg.arc();

    exploitsByTypeDate.selectAll('.symbol path')
      .each(transitionExplode);

    function transitionExplode(d, i) {
      d.innerRadius = r0a;
      d.outerRadius = r1a;
      d3v3.select(this).transition()
        .duration(duration / 2)
        .tween('arc', tweenArc({
          innerRadius: r0b,
          outerRadius: r1b,
        }));
    }

    function tweenArc(b) {
      return function (a) {
        const path = d3v3.select(this);
        const text = d3v3.select(this.nextSibling);
        const i = d3v3.interpolate(a, b);

        for (const key in b) a[key] = b[key]; // update dataCsv
        return function (t) {
          const a = i(t);
          path.attr('d', arc(a));
          text.attr('transform', `translate(${arc.centroid(a)})translate(${width / 2},${height / 2})rotate(${((((a.startAngle + a.endAngle) / 2) + ((3 * Math.PI) / 2)) * 180) / Math.PI})`);
        };
      };
    }

    setTimeout(() => {
      exploitsByTypeDate.selectAll('*')
        .remove();
      exploitsByTypeDate.selectAll('g')
        .data(symbols)
        .enter()
        .append('g')
        .attr('class', 'symbol');
      lines();
    }, duration);
  }
}

addOptions();
showReel();
